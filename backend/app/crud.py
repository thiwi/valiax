"""CRUD helper functions for the Valiax backend."""

from sqlalchemy.orm import Session
from . import models, schemas
from uuid import UUID

import logging
logger = logging.getLogger(__name__)

def get_db_connections(db: Session):
    """
    Retrieve all DBConnection records from the database.

    Args:
        db (Session): SQLAlchemy database session.

    Returns:
        List of DBConnection model instances.
    """
    # Query all DBConnection entries and return them as a list
    return db.query(models.DBConnection).all()

def create_db_connection(db: Session, payload: schemas.DBConnectionCreate):
    """
    Create a new DBConnection record in the database using the provided payload.

    Args:
        db (Session): SQLAlchemy database session.
        payload (schemas.DBConnectionCreate): Data for creating a new DBConnection.

    Returns:
        The newly created DBConnection model instance.
    """
    # Instantiate a new DBConnection model by unpacking the payload dictionary
    db_obj = models.DBConnection(**payload.dict())
    db.add(db_obj)      # Add the new object to the session
    db.commit()         # Commit transaction to persist changes
    db.refresh(db_obj)  # Refresh to get updated data (e.g., autogenerated IDs)
    return db_obj


# Delete a DBConnection by ID
def delete_db_connection(db: Session, connection_id: UUID) -> bool:
    """
    Delete the DBConnection record with the specified ID.

    Args:
        db (Session): SQLAlchemy database session.
        connection_id (UUID): Unique identifier of the DBConnection to delete.

    Returns:
        True if a record was found and deleted; False otherwise.
    """
    # Query for the DBConnection by its ID
    db_obj = db.query(models.DBConnection).filter(models.DBConnection.id == connection_id).first()
    if not db_obj:
        # No matching record found, nothing to delete
        return False
    db.delete(db_obj)  # Delete the found record
    db.commit()        # Commit changes to the database
    return True

def create_column_rule(db: Session, connection_id: UUID, table: str, column: str, rule_name: str, rule_text: str, severity: str, interval: str, description: str):
    """
    Create a new ColumnRule record associated with a database connection.

    Args:
        db (Session): SQLAlchemy database session.
        connection_id (UUID): ID of the DBConnection this rule belongs to.
        table (str): Name of the table the rule applies to.
        column (str): Name of the column the rule applies to.
        rule_name (str): Name of the rule.
        rule_text (str): Text or expression defining the rule.
        severity (str): Severity level of the rule (e.g., 'critical').
        interval (str): Interval for checking the rule.
        description (str): Description of the rule.

    Returns:
        The newly created ColumnRule model instance.
    """
    # Instantiate a new ColumnRule with all provided attributes
    new_rule = models.ColumnRule(
        db_connection_id=connection_id,
        table_name=table,
        column_name=column,
        rule_name=rule_name,
        rule_text=rule_text,
        severity=severity,
        interval=interval,
        description=description
    )
    db.add(new_rule)      # Add to session
    db.commit()           # Persist to database
    db.refresh(new_rule)  # Refresh to get updated fields like ID

    # Log creation info for audit/debugging purposes
    logger.info(
        f"Created ColumnRule id={new_rule.id} for connection {connection_id}, "
        f"table={table}, column={column}, interval={interval}"
    )
    return new_rule

def update_column_rule(db: Session, rule_id: UUID, new_name: str, new_text: str, new_description: str, new_severity: str):
    """
    Update an existing ColumnRule record with new values.

    Args:
        db (Session): SQLAlchemy database session.
        rule_id (UUID): ID of the ColumnRule to update.
        new_name (str): New rule name.
        new_text (str): New rule text or expression.
        new_description (str): New description.
        new_severity (str): New severity level.

    Returns:
        Updated ColumnRule instance if found; None if no matching rule exists.
    """
    # Retrieve the rule by its ID
    rule = db.query(models.ColumnRule).filter(models.ColumnRule.id == rule_id).first()
    if not rule:
        # No rule found with the given ID
        return None

    # Update fields with new values
    rule.rule_name = new_name
    rule.rule_text = new_text
    rule.severity = new_severity
    rule.description = new_description

    db.commit()        # Save changes
    db.refresh(rule)   # Refresh to reflect updated data
    return rule

from sqlalchemy import func
from .models import ColumnRule, RuleResult, RuleRun
import datetime

def get_dashboard_kpis(
    db: Session,
    conn_id: UUID,
    date_from: datetime.date | None = None,
    date_to: datetime.date | None = None
):
    """
    Compute key performance indicators (KPIs) for the dashboard related to rule results.

    Args:
        db (Session): SQLAlchemy database session.
        conn_id (UUID): ID of the DBConnection to filter data.
        date_from (datetime.date | None): Optional start date to filter results.
        date_to (datetime.date | None): Optional end date to filter results.

    Returns:
        Dictionary containing:
            - total_violations: Total number of rule violations detected.
            - critical_violations: Number of violations with 'critical' severity.
            - affected_tables: Count of distinct tables affected by violations.
            - compliance_rate: Placeholder compliance rate (currently fixed at 100).
    """
    # Query total count of RuleResult entries for the given connection
    total = db.query(func.count(RuleResult.id)) \
        .join(ColumnRule, RuleResult.rule_id == ColumnRule.id) \
        .filter(ColumnRule.db_connection_id == conn_id)

    # Apply date filters if specified
    if date_from:
        total = total.filter(RuleResult.detected_at >= datetime.datetime.combine(date_from, datetime.time.min))
    if date_to:
        total = total.filter(RuleResult.detected_at <= datetime.datetime.combine(date_to, datetime.time.max))
    total = total.scalar() or 0  # Execute query and default to 0 if None

    # Query count of critical severity violations
    critical = db.query(func.count(RuleResult.id)) \
        .join(ColumnRule, RuleResult.rule_id == ColumnRule.id) \
        .filter(
            ColumnRule.db_connection_id == conn_id,
            ColumnRule.severity == 'critical'
        )
    # Apply same date filters
    if date_from:
        critical = critical.filter(RuleResult.detected_at >= datetime.datetime.combine(date_from, datetime.time.min))
    if date_to:
        critical = critical.filter(RuleResult.detected_at <= datetime.datetime.combine(date_to, datetime.time.max))
    critical = critical.scalar() or 0

    # Count distinct tables affected by violations
    affected = db.query(func.count(func.distinct(ColumnRule.table_name))) \
        .join(RuleResult, RuleResult.rule_id == ColumnRule.id) \
        .filter(ColumnRule.db_connection_id == conn_id)
    if date_from:
        affected = affected.filter(RuleResult.detected_at >= datetime.datetime.combine(date_from, datetime.time.min))
    if date_to:
        affected = affected.filter(RuleResult.detected_at <= datetime.datetime.combine(date_to, datetime.time.max))
    affected = affected.scalar() or 0

    # Query total number of rows checked in rule runs
    checked_rows_query = db.query(func.sum(models.RuleRun.checked_rows)) \
        .join(ColumnRule, models.RuleRun.rule_id == ColumnRule.id) \
        .filter(ColumnRule.db_connection_id == conn_id)

    # Apply optional date filters to rule run start/end time
    if date_from:
        checked_rows_query = checked_rows_query.filter(models.RuleRun.start_time >= datetime.datetime.combine(date_from, datetime.time.min))
    if date_to:
        checked_rows_query = checked_rows_query.filter(models.RuleRun.end_time <= datetime.datetime.combine(date_to, datetime.time.max))

    checked_rows = checked_rows_query.scalar() or 0

    # Compute compliance rate only if there is data
    if checked_rows > 0:
        compliance_rate = round(1 - (total / checked_rows), 4)
    else:
        compliance_rate = 1.0

    return {
        "total_violations": total,
        "critical_violations": critical,
        "affected_tables": affected,
        "compliance_rate": compliance_rate
    }

def get_dashboard_trends(
    db: Session,
    conn_id: UUID,
    date_from: datetime.date | None = None,
    date_to: datetime.date | None = None
):
    """
    Retrieve daily counts of rule violations grouped by rule name for trend visualization.

    Args:
        db (Session): SQLAlchemy database session.
        conn_id (UUID): ID of the DBConnection to filter data.
        date_from (datetime.date | None): Optional start date filter.
        date_to (datetime.date | None): Optional end date filter.

    Returns:
        List of dictionaries, each containing:
            - date (ISO string): Date of the violations.
            - rule_name (str): Name of the rule.
            - count (int): Number of violations for that rule on that date.
    """
    # Build base query selecting date truncated to day, rule name, and count of violations
    query = db.query(
        func.date_trunc('day', RuleResult.detected_at).label('date'),
        ColumnRule.rule_name.label('rule_name'),
        func.count(RuleResult.id).label('count')
    ).join(ColumnRule, RuleResult.rule_id == ColumnRule.id) \
     .filter(ColumnRule.db_connection_id == conn_id)

    # Apply optional date filters
    if date_from:
        query = query.filter(
            RuleResult.detected_at >= datetime.datetime.combine(date_from, datetime.time.min)
        )
    if date_to:
        query = query.filter(
            RuleResult.detected_at <= datetime.datetime.combine(date_to, datetime.time.max)
        )

    # Group results by date and rule name, order accordingly
    rows = query \
        .group_by('date', ColumnRule.rule_name) \
        .order_by('date', ColumnRule.rule_name) \
        .all()

    # Format results as list of dictionaries for easy consumption by frontend
    return [
        {"date": r.date.isoformat(), "rule_name": r.rule_name, "count": r.count}
        for r in rows
    ]

def get_dashboard_top_violations(
    db: Session,
    conn_id: UUID,
    date_from: datetime.date | None = None,
    date_to: datetime.date | None = None
):
    """
    Retrieve the top 5 rules and tables with the highest number of violations.

    Args:
        db (Session): SQLAlchemy database session.
        conn_id (UUID): ID of the DBConnection to filter data.
        date_from (datetime.date | None): Optional start date filter.
        date_to (datetime.date | None): Optional end date filter.

    Returns:
        Dictionary containing:
            - top_rules: List of top 5 rules with their violation counts.
            - top_tables: List of top 5 tables with their violation counts.
    """
    # Query top rules by count of violations
    top_rules = db.query(
        ColumnRule.rule_name,
        func.count(RuleResult.id).label('count')
    ).join(RuleResult, RuleResult.rule_id == ColumnRule.id) \
     .filter(ColumnRule.db_connection_id == conn_id)

    # Apply date filters if provided
    if date_from:
        top_rules = top_rules.filter(RuleResult.detected_at >= datetime.datetime.combine(date_from, datetime.time.min))
    if date_to:
        top_rules = top_rules.filter(RuleResult.detected_at <= datetime.datetime.combine(date_to, datetime.time.max))

    # Group by rule name, order by descending count, limit to top 5
    top_rules = top_rules \
     .group_by(ColumnRule.rule_name) \
     .order_by(func.count(RuleResult.id).desc()) \
     .limit(5).all()

    # Query top tables by count of violations
    top_tables = db.query(
        ColumnRule.table_name,
        func.count(RuleResult.id).label('count')
    ).join(RuleResult, RuleResult.rule_id == ColumnRule.id) \
     .filter(ColumnRule.db_connection_id == conn_id)

    # Apply same date filters
    if date_from:
        top_tables = top_tables.filter(RuleResult.detected_at >= datetime.datetime.combine(date_from, datetime.time.min))
    if date_to:
        top_tables = top_tables.filter(RuleResult.detected_at <= datetime.datetime.combine(date_to, datetime.time.max))

    # Group by table name, order by descending count, limit to top 5
    top_tables = top_tables \
     .group_by(ColumnRule.table_name) \
     .order_by(func.count(RuleResult.id).desc()) \
     .limit(5).all()

    # Return structured dictionary with top rules and tables
    return {
        "top_rules": [{"rule_name": r.rule_name, "count": r.count} for r in top_rules],
        "top_tables": [{"table_name": t.table_name, "count": t.count} for t in top_tables],
    }

def get_column_rule_by_name(db: Session, rule_name: str) -> ColumnRule | None:
    """
    Retrieve a single ColumnRule record by its unique rule_name.

    Args:
        db (Session): SQLAlchemy database session.
        rule_name (str): The rule_name to search for.

    Returns:
        The ColumnRule instance if found; otherwise None.
    """
    # Query for the first ColumnRule matching the specified rule_name
    return db.query(models.ColumnRule)\
        .filter(models.ColumnRule.rule_name == rule_name)\
        .first()

def get_rule_names(db: Session, conn_id: UUID) -> list[str]:
    """Return all distinct rule names for a connection."""
    rows = (
        db.query(models.ColumnRule.rule_name)
        .filter(models.ColumnRule.db_connection_id == conn_id)
        .distinct()
        .order_by(models.ColumnRule.rule_name)
        .all()
    )
    return [r.rule_name for r in rows]

def get_dashboard_results(
    db: Session,
    conn_id: UUID,
    date_from: datetime.date | None = None,
    date_to: datetime.date | None = None,
    limit: int = 100,
    rule_names: list[str] | None = None,
):
    """Retrieve recent rule results for a connection with optional date range."""
    query = (
        db.query(models.RuleResult, models.ColumnRule.rule_name)
        .join(models.ColumnRule, models.RuleResult.rule_id == models.ColumnRule.id)
        .filter(models.ColumnRule.db_connection_id == conn_id)
    )

    if date_from:
        query = query.filter(
            models.RuleResult.detected_at >= datetime.datetime.combine(date_from, datetime.time.min)
        )
    if date_to:
        query = query.filter(
            models.RuleResult.detected_at <= datetime.datetime.combine(date_to, datetime.time.max)
        )

    if rule_names:
        query = query.filter(models.ColumnRule.rule_name.in_(rule_names))

    rows = (
        query.order_by(models.RuleResult.detected_at.desc())
        .limit(limit)
        .all()
    )

    return [
        {
            "id": r.RuleResult.id,
            "detected_at": r.RuleResult.detected_at,
            "rule_id": r.RuleResult.rule_id,
            "result": r.RuleResult.result,
            "rule_name": r.rule_name,
        }
        for r in rows
    ]
