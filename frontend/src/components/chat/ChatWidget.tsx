import React, { useState, useRef, useEffect, FormEvent } from 'react';
import {
  Box,
  Paper,
  Typography,
  Collapse,
  Divider,
  TextField,
  Button,
  MenuItem
} from '@mui/material';
import { useTheme } from '@mui/material/styles';
import Fade from '@mui/material/Fade';
import { useStore } from '../../store/store';

import ChatHeader from './ChatHeader';
import ChatHistory from './ChatHistory';
import ChatForm from './ChatForm';
import IncludeColumnsModal from './IncludeColumnsModal';

/**
 * Represents a chat message, either from the user or the bot.
 * @interface Message
 * @property {'user' | 'bot'} from - Indicates the sender of the message.
 * @property {string} text - The content of the message.
 */
interface Message {
  from: 'user' | 'bot';
  text: string;
}

/**
 * Props for the ChatWidget component.
 * @interface ChatWidgetProps
 * @property {string} connectionId - Identifier for the database connection, used to fetch tables and columns.
 */
interface ChatWidgetProps {
  connectionId: string;
}

/**
 * ChatWidget Component
 * 
 * This component provides an interactive chat interface for users to query a database connection.
 * Users can select database columns, send prompts, and receive AI-generated responses.
 * It also supports a "rule creation" mode where the AI generates Python code rules based on selected columns.
 * 
 * The widget supports expanding/collapsing, viewing chat history, selecting columns from tables,
 * and saving generated rules back to the server.
 */
const ChatWidget: React.FC<ChatWidgetProps> = ({ connectionId }) => {
  // State to control whether the chat widget is expanded (open) or collapsed (closed).
  const [expanded, setExpanded] = useState(false);
  // State for the current user input in the chat text field.
  const [input, setInput] = useState('');
  // Array of chat messages exchanged between user and bot.
  const [messages, setMessages] = useState<Message[]>([]);
  // Loading state to indicate when a request to generate a response is in progress.
  const [loading, setLoading] = useState(false);
  // Controls visibility of the modal dialog for selecting columns to include.
  const [columnModalOpen, setColumnModalOpen] = useState(false);
  // Set of selected columns represented as strings in the format "table:column".
  const [selectedColumns, setSelectedColumns] = useState<Set<string>>(new Set(['testTable:testColumn']));
  // List of table names that are currently expanded in the columns modal.
  const [expandedTables, setExpandedTables] = useState<string[]>([]);
  // Mapping from table names to arrays of their column names.
  const [tableColumns, setTableColumns] = useState<Record<string, string[]>>({});
  // Loading status for each table's columns, keyed by table name.
  const [loadingColumns, setLoadingColumns] = useState<Record<string, boolean>>({});
  // Error messages for loading columns of each table, keyed by table name.
  const [errorColumns, setErrorColumns] = useState<Record<string, string | null>>({});
  // Flag indicating if the user is in "rule creation" mode, which changes prompt formatting and UI.
  const [ruleCreation, setRuleCreation] = useState(false);
  // Stores the Python code generated by the AI when in rule creation mode.
  const [ruleCode, setRuleCode] = useState('');
  // Description/explanation of the generated rule code.
  const [ruleDescription, setRuleDescription] = useState('');
  // Selected interval for rule execution scheduling (e.g., daily, hourly).
  const [interval, setInterval] = useState<string>('daily');
  // Access global store to retrieve available tables for the connection.
  const tables = useStore(state => state.tables);
  // Ref to the input element to manage focus.
  const inputRef = useRef<HTMLInputElement>(null);
  // Ref to the chat history container to enable auto-scrolling.
  const historyRef = useRef<HTMLDivElement>(null);

  // Access Material UI theme for styling and z-index management.
  const theme = useTheme();

  /**
   * useEffect to auto-scroll the chat history container to the bottom
   * whenever the messages array changes or the widget is expanded.
   * Ensures the latest messages are visible without user scrolling.
   */
  useEffect(() => {
    if (expanded && historyRef.current) {
      const el = historyRef.current;
      el.scrollTop = el.scrollHeight;
    }
  }, [messages, expanded]);

  // Handler to expand the chat widget when the input gains focus.
  const handleFocus = () => setExpanded(true);

  /**
   * Debugging useEffect to log the currently selected columns whenever they change.
   * Helps track user selections during development.
   */
  useEffect(() => {
    console.log('Selected columns:', Array.from(selectedColumns));
  }, [selectedColumns]);

  /**
   * Handler for toggling the expansion of a table in the columns modal.
   * When a table is expanded for the first time, it triggers loading its columns from the server.
   * 
   * @param {string} table - The name of the table to toggle.
   * @returns {function} - Event handler for expansion toggle.
   */
  const handleToggleTable = (table: string) => (_event: React.SyntheticEvent, isExpanded: boolean) => {
    // Update the list of expanded tables depending on whether this table is expanded or collapsed.
    setExpandedTables(prev =>
      isExpanded ? [...prev, table] : prev.filter(t => t !== table)
    );

    // If expanding and columns for this table are not yet loaded, fetch them.
    if (isExpanded && !tableColumns[table]) {
      // Set loading state for this table's columns.
      setLoadingColumns(prev => ({ ...prev, [table]: true }));

      // Fetch columns from the backend API for the given table and connection.
      fetch(`/api/db-connections/${connectionId}/tables/${encodeURIComponent(table)}/columns`)
        .then(res => res.json())
        .then((data: any) => {
          // The response may be an array or an object with 'columns' array.
          const cols: string[] = Array.isArray(data) ? data
            : Array.isArray(data.columns) ? data.columns : [];
          // Store the retrieved columns in state.
          setTableColumns(prev => ({ ...prev, [table]: cols }));
          // Clear any previous error for this table.
          setErrorColumns(prev => ({ ...prev, [table]: null }));
        })
        .catch(err => {
          // On error, save the error message for display.
          setErrorColumns(prev => ({ ...prev, [table]: err.message }));
        })
        .finally(() => {
          // Clear loading state regardless of success or failure.
          setLoadingColumns(prev => ({ ...prev, [table]: false }));
        });
    }
  };

  /**
   * Main handler for sending a user input to the AI backend.
   * Handles prompt construction, message state updates, and parsing AI responses.
   * Supports a special "rule creation" mode where the AI generates Python code.
   * 
   * @param {FormEvent} e - Form submission event.
   */
  const handleSend = async (e: FormEvent) => {
    e.preventDefault();
    // Trim whitespace from input to avoid sending empty messages.
    const trimmed = input.trim();
    if (!trimmed) return;

    // If in rule creation mode, clear previous generated code and description.
    if (ruleCreation) {
      setRuleCode('');
      setRuleDescription('');
    }

    // Start with the raw user input as the prompt to send.
    let promptToSend = trimmed;

    // If in rule creation mode, modify the prompt to instruct the AI to generate structured JSON.
    if (ruleCreation ) {
      // Create a list of selected columns formatted as "table.column" for context (currently unused in prompt).
      const attrList = Array.from(selectedColumns)
        .map(c => {
          const [table, col] = c.split(':');
          return `${table}.${col}`;
        })
        .join(', ');

      // Append instructions to the prompt for strict JSON formatting with specific keys.
      promptToSend =  promptToSend;
      promptToSend += ". Strictly format the response in the following style: {'code':'python code for the rule goes here', 'description':'description of the python code goes here', 'comment':'ask the user if the response is ok or if the user needs some changes to the code.'}. Not other text should be outside of this structure. Generate valid JSON. ";
      console.log(promptToSend);
    }
    
    // Add the user's message to the chat history.
    setMessages(prev => [...prev, { from: 'user', text: trimmed }]);
    // Clear the input field.
    setInput('');
    
    try {
      // The real AI call is commented out here; instead, a simulated response is used.

      // Simulated AI response with JSON structure containing code, description, and comment.
      const botText = `{ "code": "import pandas as pd;\\ndef detect_price_outliers(conn):\\n    # Load product table into DataFrame\\n    df = pd.read_sql('SELECT id, price FROM product', conn)\\n    prices = df['price']\\n    q1 = prices.quantile(0.25)\\n    q3 = prices.quantile(0.75)\\n    mask = (prices < q1) | (prices > q3)\\n    outliers = df[mask]\\n    return outliers['id'].tolist()", "description": "This function detects 50% outliers in the 'price' column from the 'product' table using IQR bounds. It returns the list of IDs for those outlier records.", "comment": "Is this function suitable for your use case? Would you like to adjust the quantile thresholds or the return format?" }`;

      // If in rule creation mode, parse and format the JSON response to extract code, description, and comment.
      if (ruleCreation) {
        try {
          // Extract the JSON object from the response string by locating the first and last braces.
          const start = botText.indexOf('{');
          const end = botText.lastIndexOf('}');
          const jsonString = start !== -1 && end !== -1
            ? botText.substring(start, end + 1)
            : botText;
          const data = JSON.parse(jsonString);

          // Format the extracted Python code for better readability:
          // - Replace escaped newlines with actual newlines.
          // - Insert line breaks after semicolons.
          // - Add indentation to each line.
          const rawCode = data.code.replace(/\\n/g, '\n');
          const withSemicolonBreaks = rawCode.replace(/;\s*/g, ';\n');
          const indented = withSemicolonBreaks
            .split('\n')
            .map((line: string) => '  ' + line.trim())
            .join('\n');

          // Update state with the formatted code and description.
          setRuleCode(indented);
          setRuleDescription(data.description);
          // Add the AI's comment as a bot message in the chat.
          setMessages(prev => [...prev, { from: 'bot', text: data.comment }]);
        } catch {
          // If JSON parsing fails, attempt a fallback extraction using regex for triple-quoted code and quoted description/comment.
          const raw = botText;
          const codeMatch = raw.match(/code":\s*"""\s*([\s\S]*?)\s*"""/);
          const descMatch = raw.match(/"description":\s*"([^"]*)"/);
          const commentMatch = raw.match(/"comment":\s*"([^"]*)"/);

          const extractedCode = codeMatch ? codeMatch[1].trim() : '';
          const extractedDescription = descMatch ? descMatch[1].trim() : '';
          const extractedComment = commentMatch ? commentMatch[1].trim() : '';

          if (extractedCode || extractedDescription) {
            // Format fallback code similarly to above.
            const rawFallback = extractedCode.replace(/\\n/g, '\n');
            const semicolonBreaksFallback = rawFallback.replace(/;\s*/g, ';\n');
            const indentedFallback = semicolonBreaksFallback
              .split('\n')
              .map(line => '  ' + line.trim())
              .join('\n');
            setRuleCode(indentedFallback);
            setRuleDescription(extractedDescription);
            setMessages(prev => [...prev, { from: 'bot', text: extractedComment }]);
          } else {
            // If no fallback found, leave the raw response as is (already added above).
          }
        }
      } else {
        // If not in rule creation mode, the botText is not added here but could be appended similarly.
      }
    } catch {
      // On any error during sending or processing, add an error message to the chat.
      setMessages(prev => [
        ...prev,
        { from: 'bot', text: 'Error sending request' }
      ]);
    } finally {
      // Clear loading state after request completes or fails.
      setLoading(false);
    }
  };

  return (
    // Container for the entire chat widget, fixed position at bottom-right of the viewport.
    <Box
      sx={{
        position: 'fixed',
        bottom: 16,
        right: 16,
        left: 'auto',
        display: 'flex',
        justifyContent: 'flex-end',
        alignItems: 'flex-end',
        zIndex: theme => theme.zIndex.tooltip
      }}
    >
      {/* Fade transition for showing the rule creation panel when expanded and ruleCreation mode is active */}
      <Fade in={expanded && ruleCreation && Boolean(ruleCode)} timeout={300}>
        <Box
          sx={{
            position: 'fixed',
            top: 80,
            bottom: 16,
            left: 16,
            width: 'calc(50vw - 24px)',
            maxHeight: 'calc(100vh - 96px)',
            overflowY: 'auto',
            bgcolor: 'background.paper',
            color: 'black',
            fontFamily: 'monospace',
            p: 2,
            zIndex: theme => theme.zIndex.tooltip - 1,
            borderRadius: '16px',
            boxShadow: theme => theme.shadows[4],
            opacity: 1,
            transition: 'opacity 0.3s ease'
          }}
        >
          {/* Title for the Python code section */}
          <Typography variant="h6">Python code</Typography>
          {/* Display the generated Python code in a preformatted block */}
          <Typography component="pre" sx={{ margin: 0, whiteSpace: 'pre-wrap', fontFamily: 'monospace' }}>
            {ruleCode}
          </Typography>
          <Divider sx={{ backgroundColor: 'black', my: 2 }} />
          {/* Title for the description section */}
          <Typography variant="h6">Description</Typography>
          {/* Display the description of the generated rule */}
          <Typography variant="body1" component="div" sx={{ mt: 1 }}>
            {ruleDescription}
          </Typography>
          {/* Dropdown to select the scheduling interval for the rule */}
          <TextField
            select
            label="Interval"
            value={interval}
            onChange={e => setInterval(e.target.value)}
            fullWidth
            sx={{ my: 2 }}
            SelectProps={{
              MenuProps: {
                sx: {
                  zIndex: (theme) => theme.zIndex.tooltip + 1,
                },
                PaperProps: {
                  sx: {
                    zIndex: (theme) => theme.zIndex.tooltip + 1,
                  },
                },
              },
            }}
          >
            {/* Various scheduling options */}
            <MenuItem value="monthly">1st of month, 01:00</MenuItem>
            <MenuItem value="monday">Every Monday, 01:00</MenuItem>
            <MenuItem value="daily">Every day, 01:00</MenuItem>
            <MenuItem value="hourly">Every hour</MenuItem>
            <MenuItem value="minutely">Every minute</MenuItem>
          </TextField>
          {/* Button to save the generated rule */}
          <Box sx={{ position: 'absolute', bottom: 16, right: 16 }}>
            <Button
              variant="contained"
              size="small"
              onClick={async () => {
                // Prevent saving if no connection or no columns selected.
                if (!connectionId || selectedColumns.size === 0) return;
                // Extract the first selected column for naming the rule.
                const [first] = Array.from(selectedColumns);
                const [table, column] = first.split(':');
                // Send the rule data to the backend API.
                const res = await fetch(
                  `/api/db-connections/${connectionId}/tables/${table}/columns/${column}/rules`,
                  {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      rule_name: `Rule for ${table}.${column}`,
                      rule_text: ruleCode,
                      interval,
                      description: ruleDescription
                    })
                  }
                );
                if (res.ok) {
                  // Notify user and add confirmation message to chat.
                  alert('Rule saved successfully.');
                  setMessages(prev => [...prev, { from: 'bot', text: 'Rule saved successfully.' }]);
                  // Collapse the chat widget after saving.
                  setExpanded(false);
                } else {
                  // Show error message if saving failed.
                  const err = await res.text();
                  alert('Error saving rule: ' + err);
                }
              }}
            >
              Save rule
            </Button>
          </Box>
        </Box>
      </Fade>
      {/* Main chat container, width changes depending on expansion state */}
      <Box sx={{
        width: expanded ? 'calc(50vw - 24px)' : 200,
        transition: 'width 0.3s ease',
        ...(!expanded && {
          bgcolor: theme.palette.primary.main,
          color: theme.palette.primary.contrastText,
        })
      }}>
        <Paper elevation={4} sx={{ borderRadius: '16px' }}>
          {/* Header component with controls to open/close the chat */}
          <ChatHeader
            expanded={expanded}
            onOpen={() => setExpanded(true)}
            onClose={() => setExpanded(false)}
          />
          {/* Collapse component to show/hide chat content */}
          <Collapse in={expanded}>
            {/* Chat history showing all messages and loading indicator */}
            <ChatHistory
              messages={messages}
              loading={loading}
              historyRef={historyRef}
            />
            {/* Chat input form with various props for interaction */}
            <ChatForm
              input={input}
              onInputChange={e => setInput(e.target.value)}
              onSubmit={handleSend}
              ruleCreation={ruleCreation}
              selectedColumns={selectedColumns}
              onRemoveColumn={(column) => {
                // Remove a selected column from the set when requested.
                setSelectedColumns(prev => {
                  const next = new Set(prev);
                  next.delete(column);
                  return next;
                });
              }}
              onToggleRuleCreation={checked => setRuleCreation(checked)}
              onOpenColumns={() => setColumnModalOpen(true)}
              onOpenChat={() => setExpanded(true)}
            />
          </Collapse>
        </Paper>
        {/* Modal dialog for selecting which columns to include in prompts */}
        <IncludeColumnsModal
          open={columnModalOpen}
          onClose={() => setColumnModalOpen(false)}
          tables={tables}
          expandedTables={expandedTables}
          onToggleTable={handleToggleTable}
          tableColumns={tableColumns}
          loadingColumns={loadingColumns}
          errorColumns={errorColumns}
          selectedColumns={selectedColumns}
          connectionId={connectionId}
          onToggleColumn={(combo, checked) => {
            // Add or remove columns from the selected set based on user interaction.
            setSelectedColumns(prev => {
              const next = new Set(prev);
              checked ? next.add(combo) : next.delete(combo);
              return next;
            });
          }}
        />
      </Box>
    </Box>
  );
};

export default ChatWidget;
